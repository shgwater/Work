---
title: 2018-10-29云分析平台
tags: 爱空间,云分析
---

# 存储过程备份
2018年12月13日 20时22分01秒

``` sql

ALTER PROCEDURE [dbo].[PF_ETL_Conversion] 
	-- Add the parameters for the stored procedure here
	
AS
BEGIN
	
	if  exists(select *  from tempdb..sysobjects where name like '#T1%')
	     drop table #T1
     	
	if  exists(select *  from tempdb..sysobjects where name like '#T2%')
	     drop table #T2

	if  exists(select *  from tempdb..sysobjects where name like '#T3%')
				drop table #T3

	-- if  exists(select *  from tempdb..sysobjects where name like '#T3%')
	 --    drop table #T3

-- 按照规则取时间

/* -- 20181203 shg 更新规则，新增若所有时间小于订单创建时间则取订单创建时间
select 
	user_id
	,contract_date
	,case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end payment_date
	,case  doc_enter_store_date when  '2099/12/31 00:00:00.000' then (case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end)  else doc_enter_store_date end doc_enter_store_date
	,case  doc_first_vaild_date when  '2099/12/31 00:00:00.000' then (case  doc_enter_store_date when '2099/12/31 00:00:00.000' then (case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end)  else doc_enter_store_date end ) 
 else doc_first_vaild_date end doc_first_vaild_date
into #T1
from (
select user_id
	,min(case  when doc_first_vaild_date is null then '2099/12/31 00:00:00.000' else doc_first_vaild_date end)  doc_first_vaild_date
	,min( case  when doc_enter_store_date is null then '2099/12/31 00:00:00.000' else doc_enter_store_date end ) doc_enter_store_date
	,min( case  when payment_date is null then '2099/12/31 00:00:00.000' else payment_date end ) payment_date
	,min( case  when contract_date is null then '2099/12/31 00:00:00.000' else contract_date end ) contract_date
	from [dbo].[Fact_Decorate_Order]
	-- where user_id = 612303
	group by user_id ) a

20181203 shg */
SELECT
	user_id
	,contract_date
	,case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end payment_date
	,case  doc_enter_store_date when  '2099/12/31 00:00:00.000' then (case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end)  else doc_enter_store_date end doc_enter_store_date
	,case  doc_first_vaild_date when  '2099/12/31 00:00:00.000' then (case  doc_enter_store_date when '2099/12/31 00:00:00.000' then (case  payment_date when  '2099/12/31 00:00:00.000'  then contract_date  else payment_date end)  else doc_enter_store_date end ) 
 else doc_first_vaild_date end doc_first_vaild_date
into #T1
from (
select user_id
	,min(case  when doc_first_vaild_date is null then '2099/12/31 00:00:00.000' else (case when doc_first_vaild_date<create_date then create_date else doc_first_vaild_date end) end)  doc_first_vaild_date
	,min( case  when doc_enter_store_date is null then '2099/12/31 00:00:00.000' else (case when doc_enter_store_date<create_date then create_date else doc_enter_store_date end) end ) doc_enter_store_date
	,min( case  when payment_date is null then '2099/12/31 00:00:00.000' else (case when payment_date<create_date then create_date else payment_date end) end ) payment_date
	,min( case  when contract_date is null then '2099/12/31 00:00:00.000' else (case when contract_date<create_date then create_date else contract_date end) end ) contract_date
	from [dbo].[Fact_Decorate_Order]
	-- where user_id = 612303
	group by user_id ) a





select a.user_id 
,orders_no 
,Rank
,create_date
,create_time
,doc_first_vaild_user -- 首次有效人
,doc_first_vaild_date 
,doc_enter_store_date
,payment_date
,un_payment_date
,contract_date
,amount
,total_amount
,payment_category
,un_payment_category
,order_states -- 订单状态
,area_code　-- 区域
,source_no -- 渠道编号
,platform -- 平台编号
,deposit_pay_sign
 into #T2
from (select top 1000000*,Row_Number()OVER(PARTITION BY user_id ORDER BY user_id,create_date) AS Rank from [dbo].[Fact_Decorate_Order]
 order by user_id,create_date) a where Rank=1

 

 select user_id
,Sum(amount) amount 
	,sum(total_amount) total_amount
	,SUM(payment_category) payment_category
	,SUM(un_payment_category) un_payment_category
into #T3 from [dbo].[Fact_Decorate_Order] group by user_id

  TRUNCATE table Fact_Decorate_Order_User

  insert into  Fact_Decorate_Order_User

 select 
	b.orders_no
,b.create_date
,b.create_time
	,a.user_id
	,case a.doc_first_vaild_date when '2099/12/31 00:00:00.000' then NULL else convert(datetime,a.doc_first_vaild_date) end doc_first_vaild_date
	,case a.doc_enter_store_date when '2099/12/31 00:00:00.000' then NULL else convert(datetime,a.doc_enter_store_date) end doc_enter_store_date
	,case a.payment_date when '2099/12/31 00:00:00.000' then NULL else convert(datetime,a.payment_date) end payment_date
	,case a.contract_date when '2099/12/31 00:00:00.000' then NULL else convert(datetime,a.contract_date) end contract_date 

	,case a.doc_first_vaild_date when  '2099/12/31 00:00:00.000' then 0 else 1  end doc_first_vaild_date_state
	,case a.doc_enter_store_date when  '2099/12/31 00:00:00.000' then 0 else 1  end doc_enter_store_date_state
	,case a.payment_date when  '2099/12/31 00:00:00.000' then 0 else 1  end payment_date_state
	,case a.contract_date when  '2099/12/31 00:00:00.000' then 0 else 1  end contract_date_state
	,b.source_no
	,b.platform
	,b.area_code
	,b.order_states
	,c.amount
	,c.total_amount
	,c.payment_category
	,c.un_payment_category
	,b.doc_first_vaild_user   -- 首次有效人

from #T1 a INNER JOIN #T2 b on a.user_id = b.user_id 
left JOIN #T3 c on a.user_id = c.user_id

END

```


# 日常工作代码备份
2018年12月18日 14时12分48秒
呼叫中心规则确定。
``` sql
-- 711672
select * from decorate_order where orders_no = 'DD20181126000833';

select * from decorate_order where user_id = '711672'; -- 订单表

select * from decorate_order_check_holly_call_record where called_no = '13424366969'; -- 通话记录表


select * from decorate_order_check_record where fk_docr_orders_no in 
(select orders_no from decorate_order where user_id = '711672') order by docr_check_time; -- 订单核实记录

select a.doc_order_repeat,a.* from decorate_order_check a where doc_order_no in
(select orders_no from decorate_order where user_id = '711672') order by doc_update_time; -- 订单核实表
```
  2018年12月21日 10时25分11秒
  采购物流仓储
``` sql 
select * from purchase_order where purchase_order_no = 'PO1120180813009';

select id-- int(10) NOT NULL AUTO_INCREMENT,
,purchase_order_no-- char(15) COLLATE utf8_bin NOT NULL COMMENT '采购单单号',
,supplier_goods_no-- varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT '供应商商品编号',
,goods_no-- char(10) COLLATE utf8_bin NOT NULL COMMENT '商品编码',
,goods_name-- varchar(250)  '商品名称【冗余】',
,goods_level-- tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '商品层级:1:独立sku或子sku,2:母sku,改版后只有子sku,合并sku',
,line_num-- smallint(5) unsigned DEFAULT '0' COMMENT '行号',
,expect_num-- decimal(10,4) '采购建议数量',
,stock_num-- decimal(10,2) NOT NULL DEFAULT '0.00' COMMENT '可退、可调拨，可采购数量',
,purchase_unit-- char(3)  '采购单位',
,purchase_unit_num-- decimal(10,4) '采购单位数量',
,gift_num-- decimal(10,4) '赠品数量',
,real_num-- decimal(10,4) '实际数量',
,base_unit-- char(3)  '基本计量单位',
,base_unit_num-- decimal(10,4) '基本单位数量',
,numerator-- smallint(5) unsigned DEFAULT NULL COMMENT '采购单位到基本单位的转换分子',
,denominator-- smallint(5) unsigned DEFAULT NULL COMMENT '采购单位到基本单位的转换分母',
,source_purchase_price-- decimal(10,4) '发出方采购单位下含税单价',
,source_total_amount-- decimal(15,5)  '发出方采购含税总金额',
,source_purchase_tax_no-- char(2)  '发出方进项税代码',
,dist_purchase_price-- decimal(10,4) '目标方采购含税单价',
,dist_total_amount-- decimal(15,5)  '目标方采购含税总金额',
,dist_purchase_tax_no-- char(2)  '目标方进项税税码',
,supply_price-- decimal(10,4) '供货价',
,supply_total_amount-- decimal(15,5)  '供货总价',
,supply_tax_no-- char(2)  '销项税',
,specification-- varchar(100)  '规格型号颜色',
,note-- varchar(100)  '备注',
,update_user-- varchar(20)  '更新人',
,update_time-- timestamp '更新时间',
,total_receive_num-- decimal(10,4) '已收数量',
,produce_code-- varchar(50) '生产码',
,produce_name-- varchar(100) '生产名称',
,goods_space-- varchar(20) '空间', 
from purchase_order_detail where purchase_order_no = 'PO1120180813009';

select * from send_order 

```

2018年12月26日 20时20分34秒
商品分类维度表整理代码
``` sql
select a.category_name
,a.category_no
,a.parent_no 
,b.category_name
,b.category_no
,b.parent_no 
,c.category_name
,c.category_no
,c.parent_no 
,d.category_name
,d.category_no
,d.parent_no 
,e.category_name
,e.category_no
,e.parent_no 
from goods.goods_category a LEFT JOIN goods.goods_category b 
on a.parent_no  = b.category_no 
LEFT JOIN goods.goods_category c
on b.parent_no  = c.category_no 
LEFT JOIN goods.goods_category d
on c.parent_no  = d.category_no 
LEFT JOIN goods.goods_category e
on d.parent_no  = e.category_no 
where a.`level` = 4;
```
2019年01月09日 10时34分10秒
缺货池报表
``` sql
select 
id  --   '编号',
,stockout_no  --   '' COMMENT '任务编号',
,type  --   '0' COMMENT '任务类型(0：审核缺货1：拣货缺货2：复核缺货)',
,real_warehouse_no  --   '' COMMENT '物理仓编号',
,logic_warehouse_no  --   '' COMMENT '逻辑仓编号',
,location_no  --   '' COMMENT '库存地点',
,goods_no  --   '' COMMENT '商品编号',
,order_num  --   '0.00' COMMENT '订单数量',
,stockout_quantity  --   '0.00' COMMENT '缺货数量',
,order_no  --   '业务单据号',
,new_order_no  --   '' COMMENT '新发货单号',
,contract_no  --   '',
,status  --   '0' COMMENT '状态(0：已创建1：已完成2：已作废)',
,create_time  --   '操作时间',
,create_user  --   '' COMMENT '创建人',
,produce_code  --   '' COMMENT '生产码',
,produce_name  --   '' COMMENT '生产名称',
 from stockout_pool 
where stockout_no = '901QH19010921961'

select * from www.decorate_order where orders_no = 'DD20180902001180'
```
2019年01月11日 16时16分23秒
更新精准营销部的字段，新增utm字段和用户穿刺表的各阶段的订单数量。

# 呼叫中心更新

2019年01月14日 16时45分36秒
mysql 组内分组排序的方法
```

-- mysql 组内分组排序
SELECT
  user_id,
  SUBSTRING_INDEX(GROUP_CONCAT(t.doc_order_no ORDER BY t.doc_update_time DESC ),',',1)  --  截取分隔符的第一个（分组汇总 order by 字段排序）
FROM (
SELECT
	a.doc_order_no,
	a.doc_last_check_user,
	a.doc_first_vaild_user,
	a.doc_update_time,
	b.user_id
FROM
	decorate_order_check a
LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no

) t
where user_id = '665851'
GROUP BY user_id
```

2019年01月14日 19时31分33秒
``` sql

select user_id,count(DISTINCT(doc_last_check_user)) from (
select a.doc_last_check_user,a.doc_first_vaild_user,a.doc_update_time,b.user_id  from decorate_order_check a left join decorate_order b on a.doc_order_no = b.orders_no) a
-- where user_id = '84045'
GROUP BY user_id HAVING count(DISTINCT(doc_last_check_user))>2
order by user_id 


select Row_Number()OVER(PARTITION BY doc_update_time ORDER BY user_id) AS Rank from
(
select a.doc_last_check_user,a.doc_first_vaild_user,a.doc_update_time,b.user_id  from decorate_order_check a left join decorate_order b on a.doc_order_no = b.orders_no)
) a



select * from decorate_order_check where doc_order_no in (
-- mysql 组内分组排序
SELECT
  SUBSTRING_INDEX(GROUP_CONCAT(t.doc_order_no ORDER BY t.doc_update_time DESC ),',',1) orders_no --  截取分隔符的第一个（分组汇总 order by 字段排序）
FROM (
SELECT
	a.doc_order_no,
	a.doc_last_check_user,
	a.doc_first_vaild_user,
	a.doc_update_time,
	b.user_id
FROM
	decorate_order_check a
LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no

) t
-- where user_id = '665851'
GROUP BY user_id
)



select * from decorate_order_check where doc_order_no in (
-- mysql 组内分组排序
SELECT
  SUBSTRING_INDEX(GROUP_CONCAT(t.doc_order_no ORDER BY t.doc_first_vaild_date DESC ),',',1) orders_no --  截取分隔符的第一个（分组汇总 order by 字段排序）
FROM (
SELECT
	a.doc_order_no,
	a.doc_last_check_user,
	a.doc_first_vaild_user,
	a.doc_update_time,
	a.doc_first_vaild_date,
	b.user_id
FROM
	decorate_order_check a
LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no

) t
-- where user_id = '665851'
GROUP BY user_id
)
```

2019年01月15日 10时40分12秒
生成用户id对应的首次有效人和最后核实人
``` sql
select 
		t1.user_id
	,t1.doc_last_check_user
	,t2.doc_first_vaild_user
 from 
		(
		-- 最后核实人
		SELECT

			a.doc_last_check_user,
			a.doc_update_time,
			b.user_id
		FROM
			(
				SELECT
					doc_order_no,
					doc_last_check_user,
					doc_first_vaild_user,
					doc_update_time
				FROM
					decorate_order_check
				WHERE
					doc_order_no IN (
						-- mysql 组内分组排序 
						SELECT
							SUBSTRING_INDEX(GROUP_CONCAT(t.doc_order_no ORDER BY t.doc_update_time DESC ),',',1) orders_no --  截取分隔符的第一个（分组汇总 order by 字段排序） 
						FROM
							(
								SELECT
									a.doc_order_no,
									a.doc_last_check_user,
									a.doc_first_vaild_user,
									a.doc_update_time,
									b.user_id
								FROM
									decorate_order_check a
								LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no
							) t -- where user_id = '665851' 
						GROUP BY
							user_id
					)
			) a
		LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no
) t1 left join 
-- 首次有效人
(

		SELECT
			-- a.doc_order_no,
			a.doc_first_vaild_user,
			a.doc_first_vaild_date,
			b.user_id
		FROM
			(
				SELECT
					doc_order_no,
					doc_last_check_user,
					doc_first_vaild_user,
					doc_first_vaild_date
				FROM
					decorate_order_check
				WHERE
					doc_order_no IN (
						-- mysql 组内分组排序 
						SELECT
							SUBSTRING_INDEX(GROUP_CONCAT(t.doc_order_no ORDER BY t.doc_first_vaild_date DESC ),',',1) orders_no --  截取分隔符的第一个（分组汇总 order by 字段排序） 
						FROM
							(
								SELECT
									a.doc_order_no,
									a.doc_last_check_user,
									a.doc_first_vaild_user,
									a.doc_first_vaild_date,
									b.user_id
								FROM
									decorate_order_check a
								LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no
							) t -- where user_id = '665851' 
						GROUP BY
							user_id
					)
			) a
		LEFT JOIN decorate_order b ON a.doc_order_no = b.orders_no
) t2 on t1.user_id = t2.user_id

```
sqlserver中实现

``` sql
select b.*,c.*,a.*
from Fact_Decorate_Order_User a left join 
(
-- 最早有效人
select 
				-- a.doc_order_no, 
				a.doc_first_vaild_user_code,
				a.doc_first_vaild_user, 
				-- a.doc_first_vaild_date, 
				a.user_id 
from 
(
select 
		top 10000000
		*,
		Row_Number()OVER(PARTITION BY user_id ORDER BY doc_first_vaild_date) AS Rank from 
		(
		select 
				-- top 100000
				a.doc_order_no, 
				a.doc_first_vaild_user_code,
				a.doc_first_vaild_user, 
				a.doc_first_vaild_date, 
				b.user_id 
		from fact_decorate_order_check a left join Fact_Decorate_Order b on a.doc_order_no = b.orders_no 
		where a.doc_first_vaild_user is not null and a.doc_first_vaild_user <>''
		) a
 order by user_id
) a where rank =  1
) b on a.user_id = b.user_id
left join 
(
-- 最后核实人
select 
				a.doc_last_check_user_code,
				a.doc_last_check_user, 
				a.user_id 
from 
(
select 
		top 10000000
		*,
		Row_Number()OVER(PARTITION BY user_id ORDER BY doc_update_time DESC) AS Rank from  -- 因为要用最后核实人，所以需要倒序
		(
		select 
				-- top 100000
				a.doc_order_no, 
				a.doc_last_check_user_code,
				a.doc_last_check_user, 
				a.doc_update_time, 
				b.user_id 
		from fact_decorate_order_check a left join Fact_Decorate_Order b on a.doc_order_no = b.orders_no 
		where a.doc_last_check_user is not null and a.doc_last_check_user <> ''
		) a
 order by user_id
) a where rank = 1
) c on a.user_id = b.user_id 
```
2019年01月17日 18时50分31秒
``` sql
-- 711672 
select * from fact_decorate_order where orders_no = 'DD20181126000833'; 
 
select * from fact_decorate_order where user_id = '711672'; -- 订单表 
 
select * from fact_decorate_order_check_holly_call_record where called_no = '13424366969'; -- 通话记录表 
 
 
select * from fact_decorate_order_check_record where fk_docr_orders_no in  
(select orders_no from fact_decorate_order where user_id = '711672') order by docr_check_time; -- 订单核实记录 
 
select a.doc_order_repeat,a.* from fact_decorate_order_check a where doc_order_no in 
(select orders_no from fact_decorate_order where user_id = '711672') order by doc_update_time; -- 订单核实表


-- 以下为通话记录表按照 电话号码和客服的分类汇总 
select called_no
,agent -- 坐席登录名
,agent_name -- 坐席姓名
,count(1) call_count -- 外呼数量
,count([begin]) call_sucess_count -- 外呼成功数量
,sum(DATEDIFF(Ss, [begin],[end]))  -- 外呼时长 单位 秒
 from fact_decorate_order_check_holly_call_record 
group by called_no,agent,agent_name


select * from Dim_Order_State


drop table Fact_Decorate_Order_Std


SELECT
	b.orders_no AS first_orders_no,
	b.source_no as first_source_no,
	a.* INTO Fact_Decorate_Order_Std
FROM
	Fact_Decorate_Order a
LEFT JOIN (
	SELECT
		source_no,
		orders_no,
		user_id
	FROM
		Fact_Decorate_Order_user
) b ON a.user_id = b.user_id

```